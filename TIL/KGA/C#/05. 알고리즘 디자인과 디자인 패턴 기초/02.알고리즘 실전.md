# 2교시 - 25.04.02
## 알고리즘 실전
### 정렬 알고리즘
- 특정 배열, 리스트, 컬렉션들을 오름차순 또는 내림차순으로 정렬 시킨다

## 선택정렬
- 헤드가 첫번쨰에서 한번 쓱 검색해보고 가장 낮은값 선택 자리를 교체한다
- 헤드가 2번째 자리로 이동 가장 낮을값 선택 자리 변경 반복한다
- 시간복잡도 - O(n²)
- 공간복잡도 - O(1)
- 불안전 정렬

## 삽입 정렬
- 사람에게 시키면 무의식적으로하는 방식 중 하나
- 데이터를 하나씩 꺼내어 정렬된 자료중 적합한 위치에 삽입하여 정렬
- 시간복잡도 - O(n²)
- 공간복잡도 - O(1)
- 크기가 작을수로 빠름 n log n(분할하는 사전작업이 필요) 보다 빠르다
- 인덱스 사용이 불가피(배열 기반으로 사용)
- 이미 정리된 상황이면 한방에 끝남 버블 정렬도 동일
- 안정 정렬
 
## 버블정렬
- 서로 인접한 2개를 비교하여 작으면 앞으로 크면 뒤로 가는 정렬
- 큰것이 뒤로 가는것이 거픔처럼 올라오는거 같다고 해서 버플 정렬이라 한다.
- 시간복잡도 - O(n²)
- 공간복잡도 - O(1)
- 인덱스 사용이 불가능한 것들에 쓰임
- 이미 정리된 상황이면 한방에 끝남 삽입 정렬도 동일
- 안정 정렬

## 병합정렬(합병정렬)
- 데이터를 2분할하여 정렬 후 병합
- 시간복잡도 - O(n log n)
- 공간복잡도 - O(n) 
- 안정 정렬

## 퀵 정렬
- 하나의 기준(피벗)으로 작은값과 큰값을 2분할하여 정렬
- 피벗을 기준으로 작은 것은 왼쪽 큰것은 오른쪽으로 분할한다
- 시간복잡도 - 평균 :O(n log n), 최악: O(n^2) = 피벗이 반 분할이 안될때가 있음(제일 작은값이나 제일 큰 값을 이 피벗인 경우)
- 공간복잡도  - O(1)
- 메모리(캐시) 친화도 높음
- 불안정 정렬


## 힙졍렬
- 힘을이용하여 우선순위가 가장 높은 요소가 가장 마지막 요소와 교체된 후 제거되는 방법을 이용
- 시간 복잡도 - O(n log n)
- 공간 복잡도 - O(1)
- 해시 테이블처럼 함정이다
- 왔다갔다를 엄청 해야 한다
- (컴퓨터는 메모리에서 불러올때 하나만 쏙 가져오는게 아니고 연달아 사용할 확율이 높으니 한번에 들고와서 cpu가 필요한 cache 영역에있는 자료를 바로 줄 수 있다.)
- 캐시는 트랜지스터를 사용하고 훨씬 빠르다 대신 비싸서 조금만 가지고 있다
- 연달아 사용하면 한 영역게있을 가능성이 있지만 띄엄띄엄쓴다면 캐시메모리 안에 없을 수 있어 계속 불러와야한다
- 그래서 더 느린거다
- 메모리(캐시) 친화도 낮음 
- 불안정 정렬

## 인트로 정렬 (하이브리드) - c#은 이걸 채택 - 메모리 친화도 낮으면
- 크기가 16 이하라면 삽입 정렬을 한다.
- 기본으로 퀵 정렬을 수행한다.
- 수행 도중 재귀 호출의 깊이가 2logn을 넘어가게 되면 4번 항목으로 넘어간다.
- 힙정렬로 넘어간다

## 팀소트 (하이버리드) - 메모리 친화도 높으면
- 크기가 작으면
- 높으면 병합정렬

# 안전 정렬과 불안정 정렬
## 불안전 정렬
- 초반에 정렬하고 다른 정렬로 했을때 순서가 바뀐다
- 속도가 빠르다
## 안전 정렬
- 초반에 정렬하고 다른 정렬로 했을때 순서가 바뀌지 않는다
- 속도가 느림


