# 2교시 - 25.04.02
# 알고리즘 실전 - 정렬
### 불안전 정렬
- 초반에 정렬하고 다른 정렬로 했을때 순서가 바뀐다
- 속도가 빠르다
## 안전 정렬
- 초반에 정렬하고 다른 정렬로 했을때 순서가 바뀌지 않는다
- 속도가 느림
# 정렬 알고리즘
- 특정 배열, 리스트, 컬렉션들을 오름차순 또는 내림차순으로 정렬 시킨다

## 선택정렬
- 헤드가 첫번쨰에서 한번 쓱 검색해보고 가장 낮은값 선택 자리를 교체한다
- 헤드가 2번째 자리로 이동 가장 낮을값 선택 자리 변경 반복한다
- 시간복잡도 - O(n²)
- 공간복잡도 - O(1)
- 불안전 정렬

## 삽입 정렬
- 사람에게 시키면 무의식적으로하는 방식 중 하나
- 데이터를 하나씩 꺼내어 정렬된 자료중 적합한 위치에 삽입하여 정렬
- 시간복잡도 - O(n²)
- 공간복잡도 - O(1)
- 크기가 작을수로 빠름 n log n(분할하는 사전작업이 필요) 보다 빠르다
- 인덱스 사용이 불가피(배열 기반으로 사용)
- 이미 정리된 상황이면 한방에 끝남 버블 정렬도 동일
- 안정 정렬
 
## 버블정렬
- 서로 인접한 2개를 비교하여 작으면 앞으로 크면 뒤로 가는 정렬
- 큰것이 뒤로 가는것이 거픔처럼 올라오는거 같다고 해서 버플 정렬이라 한다.
- 시간복잡도 - O(n²)
- 공간복잡도 - O(1)
- 인덱스 사용이 불가능한 것들에 쓰임
- 이미 정리된 상황이면 한방에 끝남 삽입 정렬도 동일
- 안정 정렬

## 병합정렬(합병정렬)
- 데이터를 2분할하여 정렬 후 병합
- 시간복잡도 - O(n log n)
- 공간복잡도 - O(n) 
- 안정 정렬

## 퀵 정렬
- 하나의 기준(피벗)으로 작은값과 큰값을 2분할하여 정렬
- 피벗을 기준으로 작은 것은 왼쪽 큰것은 오른쪽으로 분할한다
- 시간복잡도 - 평균 :O(n log n), 최악: O(n^2) = 피벗이 반 분할이 안될때가 있음(제일 작은값이나 제일 큰 값을 이 피벗인 경우)
- 공간복잡도  - O(1)
- 메모리(캐시) 친화도 높음
- 불안정 정렬


## 힙졍렬
- 힘을이용하여 우선순위가 가장 높은 요소가 가장 마지막 요소와 교체된 후 제거되는 방법을 이용
- 시간 복잡도 - O(n log n)
- 공간 복잡도 - O(1)
- 해시 테이블처럼 함정이다
- 왔다갔다를 엄청 해야 한다
- (컴퓨터는 메모리에서 불러올때 하나만 쏙 가져오는게 아니고 연달아 사용할 확율이 높으니 한번에 들고와서 cpu가 필요한 cache 영역에있는 자료를 바로 줄 수 있다.)
- 캐시는 트랜지스터를 사용하고 훨씬 빠르다 대신 비싸서 조금만 가지고 있다
- 연달아 사용하면 한 영역게있을 가능성이 있지만 띄엄띄엄쓴다면 캐시메모리 안에 없을 수 있어 계속 불러와야한다
- 그래서 더 느린거다
- 메모리(캐시) 친화도 낮음 
- 불안정 정렬

## 인트로 정렬 (하이브리드) - c#은 이걸 채택 - 메모리 친화도 낮으면
- 크기가 16 이하라면 삽입 정렬을 한다.
- 기본으로 퀵 정렬을 수행한다.
- 수행 도중 재귀 호출의 깊이가 2logn을 넘어가게 되면 4번 항목으로 넘어간다.
- 힙정렬로 넘어간다

## 팀소트 (하이버리드) - 메모리 친화도 높으면
- 크기가 작으면
- 높으면 병합정렬
- 대규모 데이터를 사용
- 안정정렬


# 알고리즘 실전 - 탐색
## 순차 탐색
- 자료구조에서 순차적으로 찾고자 하는 데이터를 탐색
- 시간 복잡도 - O(n)

## 이진 탐색
- 정렬이 된어있는 자료구조에서 2분할을 통해 데이터를 탐색
- 단, 이진탐색은 정렬이 되어있는 자료에만 적용 가능(정렬이 되어있지 않으면 탐색이 안됌)
- 사간 복잡도 - O(logn)


## 너비 우선 탐색 (Breadth-First Search)
- 그래프의 분기를 만났을 때 모든 분기들을 탐색한 뒤,
- 다음 깊이의 분기들을 탐색
- 큐를 통해 탐색
- 장점: 최단 경로를 보장
- 단점: 지금 탐색 상황에서 필요하지 않은 정점 데이터도 규에 보관할 필요가 없다
- 일반적으로 그래프에 사용을 선호함
 
## 깊이 우선 탐색 (Depth-First Search)
- 그래프의 분기를 만났을 때 최대한 깊이 내려간 뒤,
- 분기의 탐색을 마쳤을 때 다음 분기를 탐색
- 스택을 통해 구현
- 단점: 최단 결로를 보장하지 않음
- 장점: 지금 탐색상황에서 필요한 정점 데이터만 보관가능하고 탐색이 끝나면 버려도 무관하다
- 일반적으로 트리에 사용을 선호함

# 길찾기 알고리즘
## 다익스트라 알고리즘
- 거쳐가서 짧아지는 후보지는 가장 가까운 정점부터
1. 방문하지 않은 노드중에서 가장 가까운 노드를 선택한 후,
2. 선택한 노드를 거쳐서 더 짧아지는 경로가 있는 경우 대체

