# 13교시 - 25.03.28
### 리스트와 링크드리스트
# 리스트  
- c#에서는 유명한 자료 구조들을 구현해놨다
- 이것을 제네릭컬렉션이라고 했다.

## 순차 리스트
- 배열도 자료구조다
- 리스트는 배열이고 클래스로 구현되어있다.
- 리스트는 공간을 처음부터 여유있게 구현하고 할당한 만큼 일부부분을 사용하도록 하는것이다
- 유의 사항: 12크기라면 그 크기인 12를 넘어서면 2배인 24로 메모리를 재할당 한다
- 연속된 공간에 할당된다
- int는 4바이트이기 때문에 4 * 4 = 8 하면 2칸이동하는거다
- 몇개 쓰고있는지를 확인하는것이기 때문에 Length가 아닌 Count라는 것을 사용한다
- 접근에 최적화된 자료구조
 
### 차이점 
- 배열은 크기가 지정해주면 그 크기로 지정된다. 그 이상 사용은 하지 못한다(고정적인 크기), 즉 크기를 늘리거나 줄일 수 없다.(팀플이 8명이면 넘어가지 않게)
- 리스트는 크기변동이 가능하다. (동적으로 사용하고 싶을 때 사용)
- 추가하면 맨 뒤에 추가하게 된다

```
public class List
{
         /*******************************************************
         * 리스트 (List)
         * 
         * 런타임 중 크기를 확장할 수 있는 배열기반의 자료구조
         * 배열요소의 갯수를 특정할 수 없는 경우 사용이 용이
         *******************************************************/

        // <리스트 구현>
        // 리스트는 배열기반의 자료구조이며, 배열은 크기를 변경할 수 없는 자료구조
        // 리스트는 동작 중 크기를 확장하기 위해 포함한 데이터보다 더욱 큰 배열을 사용
        //
        // 크기 = 3, 용량 = 8       크기 = 4, 용량 = 8       크기 = 5, 용량 = 8
        // ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐
        // │1│2│3│ │ │ │ │ │        │1│2│3│4│ │ │ │ │        │1│2│3│4│5│ │ │ │
        // └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘


        // <리스트 삽입>
        // 중간에 데이터를 추가하기 위해 이후 데이터들을 뒤로 밀어내고 삽입 진행
        //      ↓                        ↓                        ↓
        // ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐
        // │1│2│3│4│ │ │ │ │   =>   │1│2│ │3│4│ │ │ │   =>   │1│2│A│3│4│ │ │ │
        // └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘


        // <리스트 삭제>
        // 중간에 데이터를 삭제한 뒤 빈자리를 채우기 위해 이후 데이터들을 앞으로 당김
        //      ↓                        ↓
        // ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐
        // │1│2│A│3│4│ │ │ │   =>   │1│2│ │3│4│ │ │ │   =>   │1│2│3│4│ │ │ │ │
        // └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘


        // <리스트 용량>
        // 용량을 가득 채운 상황에서 데이터를 추가하는 경우
        // 더 큰 용량의 배열을 새로 생성한 뒤 데이터를 복사하여 새로운 배열을 사용
        //
        // 1. 리스트가 가득찬 상황에서 새로운 데이터 추가 시도
        // 크기 = 8, 용량 = 8
        // ┌─┬─┬─┬─┬─┬─┬─┬─┐
        // │1│2│3│4│5│6│7│8│ ← A 추가
        // └─┴─┴─┴─┴─┴─┴─┴─┘
        //
        // 2. 새로운 더 큰 배열 생성
        // 크기 = 8, 용량 = 8          크기 = 0, 용량 = 16
        // ┌─┬─┬─┬─┬─┬─┬─┬─┐           ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
        // │1│2│3│4│5│6│7│8│ ← A 추가   │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │
        // └─┴─┴─┴─┴─┴─┴─┴─┘           └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
        //
        // 3. 새로운 배열에 기존의 데이터 복사
        // 크기 = 8, 용량 = 8          크기 = 8, 용량 = 16
        // ┌─┬─┬─┬─┬─┬─┬─┬─┐          ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
        // │1│2│3│4│5│6│7│8│ ← A 추가  │1│2│3│4│5│6│7│8│ │ │ │ │ │ │ │ │
        // └─┴─┴─┴─┴─┴─┴─┴─┘          └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
        //
        // 4. 기본 배열 대신 새로운 배열을 사용
        // 크기 = 8, 용량 = 16
        // ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
        // │1│2│3│4│5│6│7│8│ │ │ │ │ │ │ │ │ ← A 추가
        // └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
        //
        // 5. 빈공간에 데이터 추가
        // 크기 = 9, 용량 = 16
        // ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
        // │1│2│3│4│5│6│7│8│A│ │ │ │ │ │ │ │
        // └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘


        // <리스트 시간복잡도>
        // 접근    탐색    삽입    삭제
        // O(1)    O(n)    O(n)    O(n) 

        public void ListTest()
        {
            int[] array = new int[4];
            
            List<int> list = new List<int>(1200); // 1000개가 넘어가는거면 미리 지정해주면 늘려주는 과정이 없어지면서 더욱 효율이 좋아진다
            // list.Capacity = 1200;
            for (int i = 0; i < 2000; i++)
            {
                list.Add(i);
                Console.WriteLine("Count = {0}, Capacity = {1}", list.Count, list.Capacity);
            }

            return ;

            // 추가
            list.Add(1); // 맨뒤에 추가 : O(1)
            list.Add(2);
            list.Add(3);
            list.Add(4);
            list.Insert(2,999); // 중간에 끼워넣기 : O(n) "O(n)이정도면 빠른거"


            // 삭제
            list.Remove(999); // 똑같은거 찾아서 삭제하기(여러개일 경우 제일 첫번째꺼 삭제함) : O(n)
            list.RemoveAt(1); // 몇번째꺼 지우기(인덱스 위치 요소 삭제) 크기를 벗어나면 에러난다 : O(n)
            list.Remove(55); // 찾아서 지울때 없으면 무시(반화은 false)

            // 접근 : O(1)
            list[1] = 222; // 리스트는 배열로 구현되어 있기 때문에 인덱스를 통한 접근이 가능하다
            int value = list[1];

            // 탐색 : O(n)
            int index = list.IndexOf(222); // 찾아서 인덱스 가져오기
            bool contain = list.Contains(222); // 찾아서 있으면 true, 없으면 false


            int count = list.Count; // 리스트에 소유중인 갯수
            int capacity = list.Capacity; // 총 크기

        }
}

```

# 링크드 리스트
- 리스트 아쉬운점 인덱스를 밀거나 당기거나 하는 단계가 필요하다
- 연결 리스트는 연속적으로 할당되지 않는데 참조하고 있기 때문에 찾을수있다 이 하나를 노드라고 한다
- 종류 4가지: 단일 연결리스트, 원형연결리스트, 이중 연결리스트(C#), 원형 이중 연결 리스트
- 읽기, 검색O(n)  : 삽입,삭제(1)

```
public class LinkedList
{
     /**********************************************************************************
     * 연결리스트 (Linked List)
     * 
     * 데이터를 포함하는 노드들을 연결식으로 만든 자료구조
     * 데이터와 다른 데이터 지점의 참조변수를 가진 노드를 기본 단위로 사용
     * 데이터를 노드를 통해 연결식으로 구성하기 때문에 데이터의 추가/삭제에 유용
     * 노드가 메모리에 연속적으로 배치되지 않고 연결 구조로 다른 데이터의 위치를 확인(index 사용 불가)
     ***********************************************************************************/

    // <연결리스트 구현>
    // 연결리스트는 노드를 기본 단위로 연결식으로 구현
    // 노드간의 연결구조에 따라 단방향, 양방향, 원형 으로 구분
    //
    // 1. 단방향 연결리스트
    // 노드가 다음 노드를 참조
    // ┌────┬─┐  ┌────┬─┐  ┌────┬─┐  ┌────┬─┐
    // │Data│───→│Data│───→│Data│───→│Data│ │
    // └────┴─┘  └────┴─┘  └────┴─┘  └────┴─┘
    //
    // 2. 양방향 연결리스트
    // 노드가 이전/다음 노드를 참조
    // ┌─┬────┬─┐  ┌─┬────┬─┐  ┌─┬────┬─┐  ┌─┬────┬─┐
    // │ │Data│←────→│Data│←────→│Data│←────→│Data│ │
    // └─┴────┴─┘  └─┴────┴─┘  └─┴────┴─┘  └─┴────┴─┘
    //
    // 3. 원형 연결리스트
    // 노드가 이전/다음 노드를 참조하며, 시작 노드와 마지막 노드를 참조
    //  ┌──────────────────────────────────────────┐
    // ┌│┬────┬─┐  ┌─┬────┬─┐  ┌─┬────┬─┐  ┌─┬────┬│┐
    // │↓│Data│←────→│Data│←────→│Data│←────→│Data│↓│
    // └─┴────┴─┘  └─┴────┴─┘  └─┴────┴─┘  └─┴────┴─┘


    // <연결리스트 삽입>
    // 새로 추가하는 노드가 이전/이후 노드를 참조한 뒤
    // 이전/이후 노드가 새로 추가하는 노드를 참조함
    // 
    //          ┌─┬───┬─┐                      ┌─┬───┬─┐                      ┌─┬───┬─┐ 
    //          │ │ C │ │                    ┌───│ C │───┐                  ┌───│ C │───┐
    //          └─┴───┴─┘          =>        ↓ └─┴───┴─┘ ↓        =>        ↓ └─┴───┴─┘ ↓
    // ┌─┬───┬─┐         ┌─┬───┬─┐    ┌─┬───┬─┐         ┌─┬───┬─┐    ┌─┬───┬─┐ ↑     ↑ ┌─┬───┬─┐
    // │ │ A │←───────────→│ B │ │    │ │ A │←───────────→│ B │ │    │ │ A │───┘     └───│ B │ │
    // └─┴───┴─┘         └─┴───┴─┘    └─┴───┴─┘         └─┴───┴─┘    └─┴───┴─┘         └─┴───┴─┘


    // <연결리스트 삭제>
    // 삭제하는 노드의 이전 노드가 이후 노드를 참조한 뒤
    // 삭제하는 노드의 이후 노드가 이전 노드를 참조함
    // 
    //          ┌─┬───┬─┐                      ┌─┬───┬─┐                      ┌─┬───┬─┐
    //        ┌──→│ C │←──┐                    │ │ C │←──┐                    │ │ C │ │
    //        │ └─┴───┴─┘ │        =>          └─┴───┴─┘ │        =>          └─┴───┴─┘
    // ┌─┬───┬│┐         ┌│┬───┬─┐    ┌─┬───┬─┐         ┌│┬───┬─┐    ┌─┬───┬─┐         ┌─┬───┬─┐
    // │ │ A │↓│         │↓│ B │ │    │ │ A │──────────→│↓│ B │ │    │ │ A │←───────────→│ B │ │
    // └─┴───┴─┘         └─┴───┴─┘    └─┴───┴─┘         └─┴───┴─┘    └─┴───┴─┘         └─┴───┴─┘


    // <연결리스트 특징>
    // 연결리스트의 경우 데이터를 연속적으로 배치하는 배열과 다르게 연결식으로 구성
    // 따라서, 데이터의 추가/삭제 과정에서 다른 데이터의 위치와 무관하게 진행되므로 수월함(밀거나 당기거나하는 기능을 안함)
    // 하지만, 데이터의 접근 과정에서 연속적인 데이터 배치가 아니기 때문에 인덱스 사용 불가하여 처음부터 탐색해야 함
    // 따로따로 저장하기 때문에 용량이 필요 없다


    // <LinkedList의 시간복잡도>
    // 접근    탐색    삽입    삭제
    // O(n)    O(n)    O(1)    O(1)
    public void LinkedListTest()
    {
        LinkedList<string> linkedList = new LinkedList<string>();
        
        // 추가에 효율적
        LinkedListNode<string> node0 = linkedList.AddFirst("0 데이터"); // 앞에 붙이기  // O(1)
        LinkedListNode<string> node1 = linkedList.AddLast("1 데이터"); // 뒤에 붙이기  // O(1)
        LinkedListNode<string> node2 = linkedList.AddLast("2 데이터");  // O(1)
        LinkedListNode<string> node3 = linkedList.AddLast("3 데이터");  // O(1)
        LinkedListNode<string> node4 = linkedList.AddBefore(node1, "4 데이터");  // O(1)
        LinkedListNode<string> node5 = linkedList.AddAfter(node1, "5 데이터");  // O(1)
        
        // 삭제
        linkedList.Remove(node1); // O(1)
        linkedList.RemoveFirst(); // O(1)
        linkedList.RemoveLast(); // O(1)
        linkedList.Remove("1 데이터"); // O(n) 찾아서 지워야하기 때문에
        
        // 접근
        // linkedList[2] : 연결리스트는 인덱스가 없다(연속적으로 저장하지 않기 때문에 인덱스 사용이 불가능하다)
        LinkedListNode<string> prevNode = node1.Previous;
        LinkedListNode<string> nextNode = node1.Next;
        LinkedListNode<string> firstNode = linkedList.First;
        LinkedListNode<string> lastNode = linkedList.Last;
        // c#에서 양방향이기 때문에 first last를 지원한다
        
        // 탐색
        LinkedListNode<string> findNode = linkedList.Find("1 데이터");
        bool Contain = linkedList.Contains("1 데이터");

        Console.WriteLine(node1.Value);
        Console.WriteLine(node1.Next.Value);
        Console.WriteLine(node1.Previous.Value);
        
        // foreach 반복문이 있는 이유
        int[] array = new int[8];
        for (int i = 0; i < array.Length; i++)
        {
            Console.WriteLine(array[i]);
        }

        foreach (int value in array)
        {
            
        }

        LinkedList<int> list = new LinkedList<int>();
        // for (int i = 0; i < array.Length; i++)
        // {
            // Console.WriteLine(list[i]);//  반복이 불가하다 (인덱스가 없기 때문에)
        // }
        // 이런식으로 찾아야함
        // for (LinkedListNode<int> node = list.First; node != null; node = node.Next)
        // {
            // Console.WriteLine(node.Value);
        // }
        // 처음부터 끝까지 반복한다
        foreach (int node in list)
        {
            Console.WriteLine(node);
        }

    }
}
```

![스크린샷 2025-03-28 오후 12.44.59.png](img05%2F%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202025-03-28%20%EC%98%A4%ED%9B%84%2012.44.59.png)

## 많이 사용하는 자료구조
- List, Queue, Stack, Dictionary -> 배열기반
- 링크드리스트는 사용 많이 안함 이론적으로만 알자(캐시 적중률 - 캐시 메모리 친화도가 낮음)

