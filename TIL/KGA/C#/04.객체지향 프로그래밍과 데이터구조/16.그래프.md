# 15교시 - 25.03.31
- 관계도에 사용 또는 계층을 표현하기 위해
## 참고
- https://github.com/jungtaek6681/CSharp-Algorithm/tree/master/05.%20BinarySearchTree
### 그래프
- 목적에 따라 다양한 조료구조를 사용할 수 있다
- 관계도에 좋은 자료구조
- 그래프(다소 불규칙)와 트리(규칙적으로 보임) 2가지가 있다
- 순환구조가 생겼다, 부모가 2개 이상이다 
- 노드 + 간선
```
 /******************************************************************
 * 이진탐색트리 (BinarySearchTree)
 * 
 * 이진속성과 탐색속성을 적용한 트리
 * 이진탐색을 통한 탐색영역을 절반으로 줄여가며 탐색 가능
 * 이진 : 부모노드는 최대 2개의 자식노드를 가질 수 있음
 * 탐색 : 자신의 노드보다 작은 값들은 왼쪽, 큰 값들은 오른쪽에 위치
 *******************************************************************/

// <이진탐색트리 구현>
// 이진탐색트리는 모든 노드들이 최대 2개의 자식노드를 가질 수 있으며
// 자신의 노드보다 작은 값들은 왼쪽, 큰 값들은 오른쪽에 위치시킴
//
//             23
//      ┌──────┴──────┐
//      11            38
//   ┌──┴──┐       ┌──┴──┐
//   3     19      31    65
//   └─┐ ┌─┴─┐   ┌─┘     └─┐
//     6 17  22  24        87


// <이진탐색트리 탐색>
// 아래의 이진탐색트리에서 17 탐색
// 루트 노드부터 시작하여 탐색하는 값과 비교하여,
// 작은 경우 왼쪽자식노드로, 큰 경우 오른쪽자식노드를 탐색
//
//             23(↙)
//      ┌──────┴──────┐
//      11(↘)         38
//   ┌──┴──┐       ┌──┴──┐
//   3     19(↙)   31    65
//   └┐  ┌─┴─┐   ┌─┘
//    6 (17)  22  24


// <이진탐색트리 삽입>
// 아래의 이진탐색트리에서 35 삽입
// 루트 노드부터 시작하여 삽입하는 값과 비교하여,
// 작은 경우 왼쪽자식노드로, 큰 경우 오른쪽자식노드로 하강
// 만약 빈공간이라면 빈공간에 삽입
//
//             23(↘)                          23
//      ┌──────┴──────┐                ┌──────┴──────┐
//      11            38(↙)            11            38
//   ┌──┴──┐       ┌──┴──┐      =>  ┌──┴──┐       ┌──┴──┐ 
//   3     19      31(↘) 65         3     19      31    65
//   └─┐ ┌─┴─┐   ┌─┘                └─┐ ┌─┴─┐   ┌─┴─┐
//     6 17  22  24                   6 17  22  24 (35)


// <이진탐색트리 삭제>
// 1. 자식이 0개인 노드의 삭제 : 단순 삭제 진행
// 아래의 이진탐색트리에서 22 삭제
//
//             23                             23
//      ┌──────┴──────┐                ┌──────┴──────┐
//      11            38               11            38
//   ┌──┴──┐       ┌──┴──┐    =>    ┌──┴──┐       ┌──┴──┐
//   3     19      31    65         3     19      31    65
//   └─┐ ┌─┴─┐   ┌─┘                └─┐ ┌─┘     ┌─┴─┐
//     6 17 (22) 24                   6 17      24  35
//
// 2. 자식이 1개인 노드의 삭제 : 삭제하는 노드의 부모와 자식을 연결 후 삭제
// 아래의 이진탐색트리에서 38 삭제
//
//            23                              23
//     ┌──────┴──────┐                 ┌──────┴──────┐
//     11            (38)              11            31
//  ┌──┴──┐       ┌──┘        =>    ┌──┴──┐       ┌──┴──┐ 
//  3     19      31                3     19      24    35
//  └─┐ ┌─┴─┐   ┌─┴─┐               └─┐ ┌─┴─┐
//    6 17  22  24  35                6 17  22
//
// 3. 자식이 2개인 노드의 삭제 : 삭제하는 노드를 기준으로 오른쪽자식 중 가장 작은 값 노드와 교체 후 삭제
// 아래의 이진탐색트리에서 23 삭제
//
//           (23)                             24                              24
//     ┌──────┴──────┐                 ┌──────┴──────┐                 ┌──────┴──────┐
//     11            38                11            38                11            38
//  ┌──┴──┐       ┌──┴──┐     =>    ┌──┴──┐       ┌──┴──┐     =>    ┌──┴──┐       ┌──┴──┐ 
//  3     19      24    49          3     19     (23)   49          3     19      35   49
//  └─┐ ┌─┴─┐     └─┐               └─┐ ┌─┴─┐     └─┐               └─┐ ┌─┴─┐
//    6 17  22      35                6 17  22      35                6 17  22


// <이진탐색트리 정렬>
// 이진탐색트리는 중위순회시 오름차순으로 정렬됨
//
//             7
//      ┌──────┴──────┐
//      4             11
//   ┌──┴──┐       ┌──┴──┐
//   2     5       9     12
// ┌─┴─┐   └─┐   ┌─┴─┐
// 1   3     6   8   10
//
// 중위순회 : ((1, 2, 3), 4, (5, 6)), 7, ((8, 9, 10), 11, 12)
//            => 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12


// <이진탐색트리 주의점>
// 이진탐색트리는 최악의 상황에 노드들이 한쪽 자식으로만 추가되는 불균형 현상이 발생 가능
// 이 경우 탐색영역이 절반으로 줄여지지 않기 때문에 시간복잡도 증가
//
//           5
//         ┌─┘
//         4
//       ┌─┘
//       3
//     ┌─┘
//     2
//   ┌─┘
//   1
//
// 이러한 현상을 막기 위해 자가균형기능을 추가한 트리의 사용이 일반적
// 자가균형트리는 회전을 이용하여 불균형이 있는 상황을 해결
//
//       8                        5
//    ┌──┴──┐   -- 우회전 ->   ┌──┴──┐
//    5     9                  3     8
//  ┌─┴─┐       <- 좌회전 --       ┌─┴─┐      
//  3   6                          6   9 
//
// 대표적인 방식으로 Red-Black Tree, AVL Tree 등을 통해 불균형상황을 파악


// <이진탐색트리 시간복잡도>
// - 평균 -
// 접근       탐색       삽입       삭제
// O(logn)    O(logn)    O(logn)    O(logn)
//
// - 최악 -
// 접근       탐색       삽입       삭제
// O(n)       O(n)       O(n)       O(n)
```

### 트리
- 하나의 뿌리
- 계층에 대해 좋은 구조
- 부모가 하나다
- 순환 구조가 아니다
- 자식 - 부모 관계
```
 /*******************************************************************************
 * 트리 (Tree)
 * 
 * 계층적인 자료를 나타내는데 자주 사용되는 자료구조
 * 부모노드가 여러자식노드들을 가질 수 있는 1 대 다 구조
 * 한 노드에서 출발하여 다시 자기 자신의 노드로 돌아오는 순환구조를 가지지 않음
 ********************************************************************************/

// <트리 구성>
// 부모(Parent) : 루트 노드 방향으로 직접 연결된 노드
// 자식(Child)  : 루트 노드 반대방향으로 직접 연결된 노드
//
// 뿌리(root)   : 부모노드가 없는 최상위 노드, 트리의 깊이 0에 하나만 존재
// 가지(Branch) : 부모노드와 자식노드가 모두 있는 노드, 트리의 중간에 존재
// 잎(Leaf)     : 자식노드가 없는 노드, 트리의 끝에 존재
//
// 길이(Length) : 출발 노드에서 도착 노드까지 거치는 수
// 깊이(Depth)  : 루트 노드부터의 길이
// 차수(Degree) : 자식노드의 갯수
//
//             뿌리                  - 깊이 0
//        ┌─────┼─────┐
//       가지  가지  가지            - 깊이 1
//  ┌─────┤     │     │
// 가지  가지   잎   가지            - 깊이 2
//  │     │           ├────┬────┐
//  잎    잎         가지  잎   잎   - 깊이 3
//                    ├────┐
//                    잎   잎        - 깊이 4


// <트리 사용처>
// 주로 계층구조를 가질 수 있는 자료나 효율적인 검색에 많이 사용됨
// ex) 윈도우의 폴더 구조, 문서의 목차, 데이터 베이스 & 검색 엔진의 구조
//     상위스킬을 배워야 하위스킬을 배울 수 있는 스킬트리


// <트리 구현>
// 노드를 기반으로 부모노드와 자식노드들을 보관할 수 있도록 구성
        // 자식노드들의 최대갯수가 정해져 있는 경우 배열로, 정해지지 않은 경우 리스트로 구현
```

## 차이점 요약
![스크린샷 2025-03-31 오후 1.03.11.png](img05%2F%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202025-03-31%20%EC%98%A4%ED%9B%84%201.03.11.png)


